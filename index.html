<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Room1 & Room2 - 360Â° è™›æ“¬å°è¦½</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Microsoft JhengHei', 'Segoe UI', Arial, sans-serif;
            overflow: hidden;
            background: #000;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
        }
        
        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            padding: 15px 25px;
            border-radius: 50px;
            display: flex;
            gap: 15px;
            align-items: center;
            z-index: 100;
            backdrop-filter: blur(10px);
        }
        
        .control-btn {
            background: rgba(255, 255, 255, 0.9);
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s;
            color: #333;
            font-family: inherit;
        }
        
        .control-btn:hover {
            background: #fff;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(255, 255, 255, 0.3);
        }
        
        .control-btn.active {
            background: #4CAF50;
            color: white;
        }
        
        #scene-indicator {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 30px;
            border-radius: 25px;
            font-size: 18px;
            font-weight: 600;
            z-index: 100;
            backdrop-filter: blur(10px);
            text-align: center;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 18px;
            z-index: 200;
            text-align: center;
            background: rgba(0, 0, 0, 0.8);
            padding: 30px 50px;
            border-radius: 15px;
        }
        
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        #info {
            position: absolute;
            bottom: 100px;
            left: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            font-size: 13px;
            z-index: 100;
            backdrop-filter: blur(10px);
            line-height: 1.8;
        }
        
        #debug-info {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            color: #4CAF50;
            padding: 10px 15px;
            border-radius: 5px;
            font-size: 11px;
            font-family: monospace;
            z-index: 100;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div class="spinner"></div>
        <div>è¼‰å…¥å…¨æ™¯åœ–ä¸­...</div>
    </div>
    
    <div id="container"></div>
    
    <div id="scene-indicator">
        <div id="current-scene-name">Room 1</div>
    </div>
    
    <div id="info">
        <div>ğŸ–±ï¸ æ‹–æ›³æ»‘é¼ ï¼šç’°è¦–å››å‘¨</div>
        <div>ğŸ” æ»¾è¼ªï¼šç¸®æ”¾è¦–é‡</div>
        <div>ğŸ’š ç¶ è‰²çƒé«”ï¼šåˆ‡æ›æˆ¿é–“</div>
        <div>ğŸšª æˆ–ä½¿ç”¨åº•éƒ¨æŒ‰éˆ•åˆ‡æ›</div>
    </div>
    
    <div id="debug-info">
        ç†±é»ç‹€æ…‹ï¼š<span id="hotspot-status">è¼‰å…¥ä¸­...</span>
    </div>
    
    <div id="controls">
        <button class="control-btn" id="switchRoomBtn">ğŸšª åˆ‡æ›æˆ¿é–“</button>
        <button class="control-btn" id="autoRotateBtn">ğŸ”„ è‡ªå‹•æ—‹è½‰</button>
        <button class="control-btn" id="fullscreenBtn">â›¶ å…¨è¢å¹•</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // ============================================
        // å ´æ™¯é…ç½®
        // ============================================
        const scenes = {
            room1: {
                name: 'Room 1',
                image: 'images/Room1.png',
                // æŠŠç†±é»æ”¾åœ¨æ­£å‰æ–¹ï¼Œå®¹æ˜“çœ‹åˆ°
                hotspot: {
                    targetScene: 'room2',
                    position: { x: 0, y: 0, z: 300 },  // æ­£å‰æ–¹
                    label: 'â†’ Room 2'
                }
            },
            room2: {
                name: 'Room 2',
                image: 'images/Room2.png',
                hotspot: {
                    targetScene: 'room1',
                    position: { x: 0, y: 0, z: 300 },  // æ­£å‰æ–¹
                    label: 'â† Room 1'
                }
            }
        };

        // ============================================
        // Three.js è¨­ç½®
        // ============================================
        let scene, camera, renderer, sphere, currentHotspot;
        let isUserInteracting = false;
        let onPointerDownMouseX = 0, onPointerDownMouseY = 0;
        let lon = 0, onPointerDownLon = 0;
        let lat = 0, onPointerDownLat = 0;
        let phi = 0, theta = 0;
        let autoRotate = false;
        let currentSceneId = 'room1';
        let raycaster, mouse;

        function init() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(
                80,
                window.innerWidth / window.innerHeight,
                1,
                3000
            );
            camera.position.set(0, 0, 0.1);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.getElementById('container').appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            loadScene('room1');

            document.addEventListener('pointerdown', onPointerDown);
            document.addEventListener('pointermove', onPointerMove);
            document.addEventListener('pointerup', onPointerUp);
            document.addEventListener('wheel', onDocumentMouseWheel);
            document.addEventListener('click', onDocumentClick);
            window.addEventListener('resize', onWindowResize);

            document.getElementById('switchRoomBtn').addEventListener('click', switchRoom);
            document.getElementById('autoRotateBtn').addEventListener('click', toggleAutoRotate);
            document.getElementById('fullscreenBtn').addEventListener('click', toggleFullscreen);
        }

        function loadScene(sceneId) {
            const sceneData = scenes[sceneId];
            if (!sceneData) {
                console.error('Scene not found:', sceneId);
                return;
            }

            currentSceneId = sceneId;
            document.getElementById('loading').style.display = 'block';
            document.getElementById('current-scene-name').textContent = sceneData.name;

            const loader = new THREE.TextureLoader();
            loader.load(
                sceneData.image,
                (texture) => {
                    if (sphere) {
                        scene.remove(sphere);
                    }
                    if (currentHotspot) {
                        scene.remove(currentHotspot);
                    }

                    const geometry = new THREE.SphereGeometry(500, 60, 40);
                    geometry.scale(-1, 1, 1);
                    const material = new THREE.MeshBasicMaterial({ map: texture });
                    sphere = new THREE.Mesh(geometry, material);
                    scene.add(sphere);

                    if (sceneData.hotspot) {
                        createHotspot(sceneData.hotspot);
                    }

                    document.getElementById('loading').style.display = 'none';
                    
                    console.log('âœ“ å ´æ™¯è¼‰å…¥å®Œæˆ:', sceneData.name);
                    console.log('âœ“ ç†±é»ä½ç½®:', sceneData.hotspot.position);
                },
                undefined,
                (error) => {
                    console.error('è¼‰å…¥å…¨æ™¯åœ–å¤±æ•—:', error);
                    document.getElementById('loading').innerHTML = 
                        '<div class="spinner"></div>' +
                        '<div>è¼‰å…¥å¤±æ•—</div>' +
                        '<div style="font-size: 12px; margin-top: 10px;">è«‹ç¢ºèªåœ–ç‰‡è·¯å¾‘æ­£ç¢º</div>';
                }
            );
        }

        function createHotspot(hotspotData) {
            // å‰µå»ºä¸€å€‹è¼ƒå¤§çš„ç™¼å…‰çƒé«”
            const hotspotGeometry = new THREE.SphereGeometry(30, 32, 32);
            const hotspotMaterial = new THREE.MeshBasicMaterial({
                color: 0x00FF00,  // äº®ç¶ è‰²
                transparent: true,
                opacity: 0.7,
                emissive: 0x00FF00,  // ç™¼å…‰æ•ˆæœ
                emissiveIntensity: 0.5
            });
            
            currentHotspot = new THREE.Mesh(hotspotGeometry, hotspotMaterial);
            currentHotspot.position.set(
                hotspotData.position.x,
                hotspotData.position.y,
                hotspotData.position.z
            );
            currentHotspot.userData = { 
                targetScene: hotspotData.targetScene,
                label: hotspotData.label
            };
            scene.add(currentHotspot);

            // æ›´æ–°ç‹€æ…‹é¡¯ç¤º
            document.getElementById('hotspot-status').textContent = 
                `å·²å‰µå»º (${hotspotData.label})`;
            
            console.log('âœ“ ç†±é»å·²å‰µå»º:', hotspotData.label, 'at', hotspotData.position);
        }

        function animateHotspot() {
            if (currentHotspot) {
                // è„ˆå‹•æ•ˆæœ
                const scale = 1 + Math.sin(Date.now() * 0.003) * 0.3;
                currentHotspot.scale.set(scale, scale, scale);
                
                // æ—‹è½‰æ•ˆæœ
                currentHotspot.rotation.y += 0.01;
            }
        }

        function onPointerDown(event) {
            isUserInteracting = true;
            onPointerDownMouseX = event.clientX;
            onPointerDownMouseY = event.clientY;
            onPointerDownLon = lon;
            onPointerDownLat = lat;
        }

        function onPointerMove(event) {
            if (isUserInteracting) {
                lon = (onPointerDownMouseX - event.clientX) * 0.1 + onPointerDownLon;
                lat = (event.clientY - onPointerDownMouseY) * 0.1 + onPointerDownLat;
            }
        }

        function onPointerUp() {
            isUserInteracting = false;
        }

        function onDocumentMouseWheel(event) {
            const fov = camera.fov + event.deltaY * 0.05;
            camera.fov = THREE.MathUtils.clamp(fov, 80, 120);
            camera.updateProjectionMatrix();
        }

        function onDocumentClick(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            if (currentHotspot) {
                const intersects = raycaster.intersectObject(currentHotspot);
                if (intersects.length > 0) {
                    console.log('âœ“ ç†±é»è¢«é»æ“Šï¼åˆ‡æ›åˆ°:', currentHotspot.userData.targetScene);
                    const targetScene = currentHotspot.userData.targetScene;
                    loadScene(targetScene);
                }
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function switchRoom() {
            const nextScene = currentSceneId === 'room1' ? 'room2' : 'room1';
            console.log('âœ“ åˆ‡æ›æˆ¿é–“:', nextScene);
            loadScene(nextScene);
        }

        function toggleAutoRotate() {
            autoRotate = !autoRotate;
            const btn = document.getElementById('autoRotateBtn');
            btn.classList.toggle('active');
        }

        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                document.exitFullscreen();
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            if (autoRotate && !isUserInteracting) {
                lon += 0.1;
            }

            lat = Math.max(-85, Math.min(85, lat));
            phi = THREE.MathUtils.degToRad(90 - lat);
            theta = THREE.MathUtils.degToRad(lon);

            const x = 500 * Math.sin(phi) * Math.cos(theta);
            const y = 500 * Math.cos(phi);
            const z = 500 * Math.sin(phi) * Math.sin(theta);

            camera.lookAt(x, y, z);

            animateHotspot();

            renderer.render(scene, camera);
        }

        init();
        animate();
    </script>
</body>
</html>
